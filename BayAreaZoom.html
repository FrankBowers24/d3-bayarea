<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>D3: Bay Area Income by Zip Code</title>
  <script data-require="jquery@2.1.3" data-semver="2.1.3" src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script src="jquery.auto-complete.min.js"></script>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <style type="text/css">

         header, #controlForm {
          border: solid 1px;
         }
         text {
            color: black;
            fill: black;
            font-size: 12px;
            font-family: sans-serif;
            width: 50px;
            height: 14px;
           }

           h1 {
             text-align: center;
             font-family: sans-serif;
           }


            path:hover {
                fill: lightskyblue;
            }
            .selected {
                fill: blue;
            }
            #controlForm {
                padding: 15px;
            } 
            #statList {
            	margin-bottom: 10px;
            }  
            .tt {
                /*position: absolute;*/
                opacity: 0.95;
                background-color: white;
                border: 3px;
                border-color: gray;
                margin-top: 10px;
                
            }
            #tipInfo {
                width: 450;
                height: 360;
                padding: 10px;
            }
            #tipLocation {
                color: white;
                background-color: #006837;
                font-family: 'Roboto Condensed', sans-serif;
                font-size: 1.8em;
                padding: 7px;
                text-align: center;

            }
            .hidden {
                visibility: hidden;
            }


             /*   Pie styling */
            .labels {
                font-size: 10px;
            }

            .innerLabels text {
                font-size: 10px;
                fill: white;
            }
            path.slice{
                stroke-width:2px;
            }

            polyline{
                opacity: .3;
                stroke: black;
                stroke-width: 2px;
                fill: none;
            }
            .leftTop {
                position: fixed;
                z-index: 130;
                top: 0px;
                left: 0px;
                width: 450px;
            }
            .rightSide {
                position:absolute;
                top: 0px;
                left: 450px;
                overflow: scroll;
            }
            .tipInfo svg {
                width: 450;
                height: 300;
            }

            /* autoComplete styles */
        .autocomplete-suggestions {
            text-align: left; cursor: default; border: 1px solid #ccc; border-top: 0; background: #fff; box-shadow: -1px 1px 3px rgba(0,0,0,.1);

            /* core styles should not be changed */
            position: absolute; display: none; z-index: 9999; max-height: 254px; overflow: hidden; overflow-y: auto; box-sizing: border-box;
        }
        .autocomplete-suggestion { position: relative; padding: 0 .6em; line-height: 23px; white-space: nowrap; overflow: hidden; font-size: 1.02em; color: #333; }
        .autocomplete-suggestion b { font-weight: normal; color: #1f8dd6; }
        .autocomplete-suggestion.selected { background: #f0f0f0; }
  </style>
</head>

<body>
  <div class="leftTop">
    <header>
      <h1>Bay Area Stats</h1>
    </header>

    <form id="controlForm" name="controlForm">
      <select id="statList" >
        <option value="0">
          Income
        </option>

        <option value="1">
          Race/Ethnicity
        </option>
      </select> <select id="raceList" class="hidden">
        <option value="1">
          Latino
        </option>

        <option value="2">
          White
        </option>

        <option value="3">
          African American
        </option>

        <option value="4">
          Native American
        </option>

        <option value="5">
          Asian
        </option>

        <option value="6">
          Pacific Islander
        </option>

        <option value="7">
          Other Race
        </option>

        <option value="8">
          Mixed Race
        </option>
      </select> <select id="asianList" class="hidden">
        <option value="0">
          All
        </option>

        <option value="1">
          Asian Indian
        </option>

        <option value="2">
          Bangladeshi
        </option>

        <option value="3">
          Cambodian
        </option>

        <option value="4">
          Mainland Chinese
        </option>

        <option value="5">
          Filipino
        </option>

        <option value="6">
          Hmong
        </option>

        <option value="7">
          Japanese
        </option>

        <option value="8">
          Korean
        </option>

        <option value="9">
          Laotian
        </option>

        <option value="10">
          Pakistani
        </option>

        <option value="11">
          Taiwanese
        </option>

        <option value="12">
          Thai
        </option>

        <option value="13">
          Vietnamese
        </option>
      </select> <br>
      <input id="selectInput" type="text" placeholder="City or Zip Code"> <button id="selectButton" type=
      "button">Select</button>
    </form>

    <div class="tooltip hidden" id="tt">
      <div id="tipContainer">
        <div id="tipLocation"></div>

        <div id="tipInfo"></div>
      </div>
    </div>
  </div>

  <div class="rightSide"></div><script type="text/javascript">


  (function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LabeledPie = factory();
  }
  }(this, function () {

    var LabeledPie = function(parent) {

        var svg = d3.select(parent)
            .append("svg")
            .append("g");

        this.svg = svg;

        d3.select(parent).select("svg").attr("width", "450").attr("height", "320");

        this.svg.append("g")
            .attr("class", "slices");
        this.svg.append("g")
            .attr("class", "labels");
        this.svg.append("g")
            .attr("class", "innerLabels");
        this.svg.append("g")
            .attr("class", "lines");

        this.width = 160,
        this.height = 160;
        this.radius = Math.min(this.width, this.height) / 2;

        this.pie = d3.layout.pie()
            .sort(null);

        this.arc = d3.svg.arc()
            .outerRadius(this.radius * 0.8)
            .innerRadius(this.radius * 0.4);

        this.outerArc = d3.svg.arc()
            .innerRadius(this.radius * 0.85)
            .outerRadius(this.radius * 0.85);

        this.edgeArc = d3.svg.arc()
            .innerRadius(this.radius * 0.8)
            .outerRadius(this.radius * 0.8);

        this.minimumDisplayedPercentage = 6;

        this.svg.attr("transform", "translate(" + 195 + "," + 110 + ")");

        this.minimumDisplayedLabel = 3;

        function pointToArray(point) {
            return [point.x, point.y];
        }

        function transitionLine(index, oldY, newY) {
            var delta = newY - oldY;
            var points;
            var pt0;
            var pt1;
            var pt2;
            var lineElement;
            svg.select(".lines").selectAll("polyline").each(function(d,i) {
                if (i === index) {
                    lineElement = this;
                }
            });
            points = lineElement.points;
            pt0 = pointToArray(points.getItem(0));
            pt1 = pointToArray(points.getItem(1));
            pt2 = pointToArray(points.getItem(2));

            d3.select(lineElement)
                .transition().duration(500)
                .attrTween("points", function(d){
                    return function(t) {
                        pt1[1] = oldY + t * delta;
                        pt2[1] = oldY + t * delta;
                        return [pt0, pt1, pt2];
                    };          
                });
        }

        function transitionOverlappingLabel(textElement, newY) {
            var matrix = textElement.transform.baseVal[0].matrix;
            var oldY = matrix.f;
            var pos = [matrix.e, matrix.f];
            var delta = newY - oldY;

            d3.select(textElement)
                .transition().duration(500)
                .attrTween("transform", function(d) {
                    return function(t) {
                        pos[1] = oldY + t * delta;
                        return "translate("+ pos +")";
                    };
                });
        }

        function adjustOverlappingLabels(labels) {
            var lastY = Infinity;  // matrix.f is y
            var matrix;
            var currentY;
            for (var i = 0; i < labels.length; i++ ) {
                matrix = labels[i].transform.baseVal[0].matrix;
                currentY = matrix.f;
                var height = labels[i].getBBox().height;
                if (currentY > (lastY - height)) {
                    currentY = lastY - height;
                    transitionOverlappingLabel(labels[i], currentY);
                    transitionLine(+labels[i].dataset.index, matrix.f, currentY);
                }
                lastY = currentY;
            }
        }

        function getOverlappingLabels() {
            var leftLabels = [];
            var rightLabels = [];

            svg.select(".labels").selectAll("text").each(function(d, index) {
                var str = this.outerHTML;
                if (!str.match("opacity: 0")) {  // only look at visible labels
                    this.dataset.index = index;
                    if (str.match("text-anchor: end")) {
                        leftLabels.push(this);
                    } else {
                        rightLabels.push(this);
                    }
                }
            });
            adjustOverlappingLabels(leftLabels);
            adjustOverlappingLabels(rightLabels.reverse());
            return true;  // return true to stop timer from firing again
        }

         
        LabeledPie.prototype.setLabels = function(labels) {
            this.labels = labels;
        }

        LabeledPie.prototype.setColorScale = function(color) {
            this.color = color;
        }



         LabeledPie.prototype.change = function(data) {

            var radius = this.radius;
            var labels = this.labels;
            var minimumDisplayedPercentage = this.minimumDisplayedPercentage;
            var arc = this.arc;
            var outerArc = this.outerArc;
            var edgeArc = this.edgeArc;
            var svg = this.svg;
            var pie = this.pie;
            var color = this.color;
            var minimumDisplayedLabel = this.minimumDisplayedLabel;


            var sum = d3.sum(data);

            function getPercentage(d) {
                return Math.round(d.value/sum*100);
            }

            function getTitle(d, i) {
              return labels[i] + ": " + d.value + ", " + getPercentage(d);
            }

            /* ------- PIE SLICES -------*/
            var slice = svg.select(".slices").selectAll("path.slice")
                .data(pie(data));

            slice.enter()
                .insert("path")
                .style("fill", function(d, i) { return color(i); })
                .attr("class", "slice");

        /*
            slice.append("svg:title")
                   .text(function(d, i) { 
                    return getTitle(d, i); })
        */

            slice       
                .transition().duration(1000)
                .attrTween("d", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        return arc(interpolate(t));
                    };
                })

            slice.exit()
                .remove();

            /* ------- TEXT LABELS -------*/

            var text = svg.select(".labels").selectAll("text")
                .data(pie(data));

            text.enter()
                .append("text")
                .attr("dy", ".35em")
                .text(function(d, i) {
                    return labels[i];
                });
            
            function midAngle(d){
                return d.startAngle + (d.endAngle - d.startAngle)/2;
            }

            text.transition().duration(1000)
               .style("opacity", function(d) {
                    return getPercentage(d) < minimumDisplayedLabel ? 0 : 1;
                })
                .attrTween("transform", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                        return "translate("+ pos +")";
                    };
                })
                .styleTween("text-anchor", function(d){
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        return midAngle(d2) < Math.PI ? "start":"end";
                    };
                });

            text.exit()
                .remove();

                d3.timer(getOverlappingLabels, 1000);


            /* ------- SLICE TO TEXT POLYLINES -------*/

            var polyline = svg.select(".lines").selectAll("polyline")
                .data(pie(data));
            
            polyline.enter()
                .append("polyline");

            polyline.transition().duration(1000)
                .style("opacity", function(d) {
                    return getPercentage(d) < minimumDisplayedLabel ? 0 : 0.3;
                })
                .attrTween("points", function(d){
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
                        return [edgeArc.centroid(d2), outerArc.centroid(d2), pos];
                    };          
                });
            
            polyline.exit()
                .remove();

        /* ------- PERCENTAGE LABELS -------*/

            var percent = svg.select(".innerLabels").selectAll("text")
                .data(pie(data));

            percent.enter()
                .insert("text")
                .attr("dy", ".35em");

            percent.transition().duration(1000)
            /*
                .tween("text", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var percent = getPercentage(d2);
                        this.textContent = percent > minimumDisplayedPercentage ? Math.round(percent) + "%" : "";

                    };
                })
  */
               .text(function(d) {
                    var percent = getPercentage(d);
                    return percent > minimumDisplayedPercentage ? Math.round(percent) + "%" : "";
                })
               .style("opacity", function(d) {
                    return d.value/sum*100 > minimumDisplayedPercentage ? 1 : 0;
                })
                .attrTween("transform", function(d, i) {
                    var bbox = this.getBBox();
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = arc.centroid(d2);
                        pos[0] = pos[0] - bbox.width/2;
                        //pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                        return "translate("+ pos +")";
                    };
                });

            percent.exit()
                .remove();


        };
    };

    return LabeledPie;
  }));

  var incomePie = new LabeledPie("#tipInfo");

  var setPieLabels = function(labelConfig, key) {

    // reset income pie
    d3.select("#tipInfo").select("svg").remove();
    incomePie = new LabeledPie("#tipInfo");

    var color = d3.scale.ordinal()
      .domain(labelConfig[key]["domain"])
      .range(labelConfig[key]["range"]);

    incomePie.setLabels(labelConfig[key]["labels"]);
    incomePie.setColorScale(color);

  };

  var pieLabelConfig = {
    income: {
      labels: ["< $25K", "$25K - $50K", "$50K - $75K", "$75K - $100K", "$100K - $200K", "> $200K"],
      domain: [0,1,2,3,4,5],
      range: ["#a50026","#f46d43","#fee08b","#d9ef8b","#66bd63","#006837"]
    },
    race: {
      labels: ["Latino", "White", "African American", "Native", "Asian", 
      "Pacific Islander", "Other Race", "Mixed Race"],
      domain: [0,1,2,3,4,5, 6, 7],
      range: ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666"]
    },
    asian: {
      labels: ["Asian Indian", "Bangladeshi", "Cambodian", "Mainland Chinese", "Filipino", "Hmong",
      "Japanese", "Korean", "Laotian", "Pakistani", "Taiwanese", "Thai", "Vietnamese"],
      domain: [0,1,2,3,4,5, 6, 7, 8, 9, 10, 11, 12],
      range:["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928", "#cccccc"]
    }
  }


  </script> <script type="text/javascript">

        var zipCodeMap = (function() {
            var width = 650;
            var height = 1000;

var projection = d3.geo.albersUsa()
    .scale(0.6 * (1 << 16))
    .translate([width / 2, height / 2]);

var path = d3.geo.path()
    .projection(projection);

var zoom = d3.behavior.zoom()
    .translate(projection.translate())
    .scale(projection.scale())
    .scaleExtent([0.6 * (1 << 16), 0.7*(1 << 17)])
    .on("zoom", zoomed);
                             
            //Define quantize scale to sort data values into buckets of color
            var color = d3.scale.quantize()
                                .range(["#a50026","#d73027","#f46d43","#fdae61","#fee08b","#ffffbf","#d9ef8b","#a6d96a","#66bd63","#1a9850","#006837"]);

            //Create SVG element
            var svg = d3.select(".rightSide")
                        .append("svg")
                        .attr("width", width)
                        .attr("height", height)
                        .call(zoom);

            var statIndex = 6;  

            var statType = "income";

            var statData;

            var geometry;

            var getPropertyValues = function() {
                var key;
                var valueMap = {};
                var zips = topojson.feature(geometry, geometry.objects.Bay_Area);
                zips.features.forEach(function(d) {
                    for (key in d.properties) {
                        valueMap[d.properties[key]] = true;
                    }
                });
                return Object.keys(valueMap);
            }

            var setStatType = function(newStatType) {
                statType = newStatType;
            }

            var setStatIndex = function(newStatIndex) {
                statIndex = newStatIndex;
            };

            function getStatValue(d, stats) {
                    var zip = d.properties.GEOID10;
                    var counts = stats[zip][statType];
                    if (counts) {
                        /*  CHANGE THIS FOR EACH RACE/INCOME LEVEL */
                        return +counts[statIndex]/+counts[0];

                    } else {
                        return null;
                    }
                
                }   

            function getTitle(d) { 
                            return d.properties.GEOID10 + ": " + d.properties.city;
                }

            function setToolTip(d, stats, values) {
                    d3.select(".tooltip").classed("hidden", false);
                    values = values || stats[d.properties.GEOID10][statType];
                    var counts = values.slice(1);
                    incomePie.change(counts);
                }   

            var updateColorDomain = function() {
                var zips = topojson.feature(geometry, geometry.objects.Bay_Area)

                var min = d3.min(zips.features, function(d) { 
                        return getStatValue(d, statData); //+d.properties.GEOID10; 
                    });
                    var max = d3.max(zips.features, function(d) { 
                        return getStatValue(d, statData); //+d.properties.GEOID10;
                     })


                color.domain([
                  min, 
                  max
                  ]);   

            }

            var updateStats = function() {

                updateColorDomain()

                svg.selectAll("path")
                       .transition().duration(1000)
                       .attr("fill", function(d) {
                            //Get data value
                            var value = getStatValue(d, statData); 
                            
                            if (value) {
                                //If value exists…
                                return color(value);
                            } else {
                                //If value is undefined…
                                return "#ccc";
                            }
                       })

            };

            var selectByData = function(field, fieldValue) {
                var matches = [];
                var aggregate = [];
                var title;
                var zip;
                var values;

                var zips = topojson.feature(geometry, geometry.objects.Bay_Area);
                zips.features.forEach(function(d) {
                    if (d.properties[field] === fieldValue) {
                        matches.push(d);
                    }
                });
                if (matches.length > 0) {
                    d3.selectAll(".selected").classed("selected", false);
                    matches.forEach(function(d) {
                        zip = d.properties.GEOID10;
                        values = statData[zip][statType];
                        for (var i = 0; i < values.length; i++) {
                            aggregate[i] = aggregate[i] || 0;
                            aggregate[i] += +values[i];
                        }
                    });
                    // var zip = d.properties.GEOID10;
                    // stats[zip][statType]
                    title = (matches.length > 1) ? fieldValue : getTitle(matches[0]);
                    d3.select("#tipLocation").text(title);
                    setToolTip(null, statData, aggregate);
                    //center(aggregate, true);
                }

                svg.selectAll("path")
                       .transition().duration(100)
                       .attr("fill", function(d) {
                            if (d.properties[field] === fieldValue) {
                                d3.select(this).classed("selected", true);
                                
                            }
                            //Get data value
                            var value = getStatValue(d, statData); 
                            
                            if (value) {
                                //If value exists…
                                return color(value);
                            } else {
                                //If value is undefined…
                                return "#ccc";
                            }
                       })

                if (matches.length > 0) {
                    aggregate = matches[0];

                    center(aggregate, true);
                }

            }

            function centerZip(ba) {

  var zips = topojson.feature(ba, ba.objects.Bay_Area),
      zip = zips.features.filter(function(d) { 

        return d.properties.GEOID10 === "94560";
         })[0];

  center(zip);
}


function center(d, transition) {
  var centroid = path.centroid(d),
      translate = projection.translate();

  projection.translate([
    translate[0] - centroid[0] + width / 2,
    translate[1] - centroid[1] + height / 2
  ]);

  zoom.translate(projection.translate());

    if (transition) {
      svg.selectAll("path").transition()
          .duration(1000)
          .attr("d", path);
    } else {
      svg.selectAll("path")
          .attr("d", path); 
    }   
}

function zoomed() {
  projection.translate(d3.event.translate).scale(d3.event.scale);
  svg.selectAll("path").attr("d", path);
}

            d3.json("data/allStats.json", function(stats) {
                statData = stats;

                d3.json("Bay_Area_Cities_topo.json", function(json) {
                    geometry = json;
                    var lastZipClick = [];
                    updateColorDomain();

                    svg.selectAll("path")
                       .data(topojson.feature(json, json.objects.Bay_Area).features)
                       .enter()
                       .append("path")
                       .attr("d", path)
                       .attr("stroke", "black")
                       .attr("fill", function(d) {
                            //Get data value
                            var value = getStatValue(d, statData); 
                            
                            if (value) {
                                //If value exists…
                                return color(value);
                            } else {
                                //If value is undefined…
                                return "#ccc";
                            }
                       })
                       .on("click", function (d) {
                            // Find previously selected, unselect
                            d3.selectAll(".selected").classed("selected", false);

                            // Select current item
                            d3.select(this).classed("selected", true);
                            d3.select("#tipLocation").text(getTitle(d));
                            setToolTip(d, statData);
                            lastZipClick = [d3.event.x, d3.event.y];
                        })
                       .append("svg:title")
                           .text(function(d) { 
                            return getTitle(d); });
                     

                     centerZip(json);      

                     d3.select(".rightSide").on("click", function() {
                        if (d3.event.x !== lastZipClick[0]  && d3.event.y !== lastZipClick[1]) {
                          d3.select(".selected").classed("selected", false);
                          d3.select(".tooltip").classed("hidden", true);
                       }
                       lastZipClick = [];
                     })
            });
        });

       setPieLabels(pieLabelConfig, "income");

       return {
          getPropertyValues: getPropertyValues,
          setStatType: setStatType,
          setStatIndex: setStatIndex,
          updateStats: updateStats,
          selectByData: selectByData
       }
  })();


  var getSelectionTitle = function() {
    var title = d3.select("#tipLocation").text();
    var retVal = d3.select("#tipLocation").text().split(':')[0];
    return retVal;
  }

  var selectByData = function(value) {
    var key = value.match(/[0-9]/) ? "GEOID10" : "city";
    zipCodeMap.selectByData(key, value);
  }

  d3.select("#statList")
    .on("change", function() {
      var statIndex = +d3.select("#statList").node().value;
      var raceIndex = +d3.select("#raceList").node().value;
      d3.select("#raceList").classed("hidden", statIndex === 0);
      d3.select("#asianList").classed("hidden", statIndex === 0 || raceIndex !== 5);
      if (statIndex === 0) {
        zipCodeMap.setStatType("income");
        zipCodeMap.setStatIndex(6);
        setPieLabels(pieLabelConfig, "income");
        selectByData(getSelectionTitle());
      } else if (statIndex === 1) {
        zipCodeMap.setStatType("race");
        zipCodeMap.setStatIndex(raceIndex);
        setPieLabels(pieLabelConfig, "race");
        selectByData(getSelectionTitle());
      }
      zipCodeMap.updateStats();
    });

  d3.select("#raceList")
    .on("change", function() {
      var raceIndex = +d3.select("#raceList").node().value;
      d3.select("#asianList").classed("hidden", raceIndex !== 5);
      zipCodeMap.setStatType("race");
      zipCodeMap.setStatIndex(raceIndex);
      zipCodeMap.updateStats();
      setPieLabels(pieLabelConfig, "race");
      selectByData(getSelectionTitle());
    });  

  d3.select("#asianList")
    .on("change", function() {
        var statIndex = +d3.select("#asianList").node().value;
        if (statIndex === 0) {
          zipCodeMap.setStatType("race");
          zipCodeMap.setStatIndex(5);
          zipCodeMap.updateStats();
          setPieLabels(pieLabelConfig, "race");
          selectByData(getSelectionTitle());
        } else {
          zipCodeMap.setStatType("asian");
          zipCodeMap.setStatIndex(statIndex);
          zipCodeMap.updateStats();
          setPieLabels(pieLabelConfig, "asian");
          selectByData(getSelectionTitle());
        }
    });

  d3.select("#selectButton")
    .on("click", function() {
        window.event.stopPropagation();
        var value = d3.select("#selectInput").node().value;
        var key = value.match(/[0-9]/) ? "GEOID10" : "city";
        zipCodeMap.selectByData(key, value); //GEOID10
    })

  /*d3.select("#selectInput")
    .on("keyup", function(){
      window.event.stopPropagation();
      var value = d3.select("#selectInput").node().value;
      var key = value.match(/[0-9]/) ? "GEOID10" : "city";
      zipCodeMap.selectByData(key, value); //GEOID10

    });*/

  $("#selectInput")
    .on("propertychange", function(){
      window.event.stopPropagation();
      var value = d3.select("#selectInput").node().value;
      var key = value.match(/[0-9]/) ? "GEOID10" : "city";
      zipCodeMap.selectByData(key, value); //GEOID10

    });


  $("#selectInput").bind('input propertychange', function(event) {
    event.stopPropagation();
    var value = d3.select("#selectInput").node().value;
    var key = value.match(/[0-9]/) ? "GEOID10" : "city";
    zipCodeMap.selectByData(key, value);      
  });

  $("#selectInput").autoComplete({
    minChars: 1,
    source: function(term, suggest){
        term = term.toLowerCase();
        var choices = zipCodeMap.getPropertyValues();
        var matches = [];
        for (i=0; i<choices.length; i++)
            if (~choices[i].toLowerCase().indexOf(term)) matches.push(choices[i]);
        suggest(matches);
    }
  });  

                
            
  </script>
</body>
</html>