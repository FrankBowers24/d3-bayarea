<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>D3: Bay Area Stats</title>
  <script data-require="jquery@2.1.3" data-semver="2.1.3" src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script src="jquery.auto-complete.min.js"></script>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <style type="text/css">

         header, #control-form {
          border: solid 1px;
         }

           h1, h5, h6 {
             text-align: center;
             font-family: sans-serif;
           }

           small {
             font-family: sans-serif;
           }

            /* map styling */
            path:hover {
                fill: lightskyblue;
            }
            .selected {
                fill: blue;
            }
            text {
                color: black;
                fill: black;
                font-size: 12px;
                font-family: sans-serif;
                width: 50px;
                height: 14px;
               }

            /* former tooltip, now pie chart */
            .tooltip {
                position: absolute;
                top: 152px;
                width: 450px;
                height: 260px;
                background-color: white;
                border-right: 1px solid black;                
            }
            .tip-info {
                display: block;
                width: 450;
                height: 270;
                padding: 10px;
                border: none;
            }
            .tip-location {
                color: white;
                background-color: #006837;
                font-family: 'Roboto Condensed', sans-serif;
                font-size: 1.8em;
                padding: 7px;
                text-align: center;
                height: 27px;

            }
            .tip-description {
                display: block;
                position: fixed;
                top: 385px;
                z-index: 2;
                margin: 0 10px;
            }
            .legend-container {
                display: block;
                position: absolute;
                border-top: 10px solid #006837;
                border-right: 1px solid black;
                border-bottom: 1px solid black;
                padding-bottom: 10px;
                top: 410px;
                z-index: 999;
                width: 450px;
            }
            .hidden {
                display: none;
            }


             /*   Pie styling */
            .labels {
                font-size: 10px;
            }

            .innerLabels text {
                font-size: 10px;
                fill: white;
            }
            path.slice{
                stroke-width:2px;
            }

            polyline{
                opacity: .3;
                stroke: black;
                stroke-width: 2px;
                fill: none;
            }

            /*  main layout */
            .left-top {
                position: fixed;
                z-index: 130;
                top: 0px;
                left: 0px;
                width: 450px;
            }
            .right-side {
                position:absolute;
                top: 0px;
                left: 450px;
                overflow: scroll;
            }
            #control-form {
                padding: 15px;
            } 
            #stat-list {
            	margin-bottom: 10px;
            } 
            button {
                padding: 4px 6px 4px 4px;
            } 

            /* legend */
            #legend {
                margin: 0 10px;
            }
            .legend-description {
                margin: 0 10px;
            }
            .list-inline {
                padding: 0px;
                border: 0px;
                margin: 0px;
            }

            li.key {
                border-top-width: 15px;
                border-top-style: solid;
                font-size: .75em;
                width: 9%;
                padding-left: 0;
                padding-right: 0;
                list-style: none;
                display: inline;
                float: left;
            }

            /* autoComplete styles */
        .autocomplete-suggestions {
            text-align: left; cursor: default; border: 1px solid #ccc; border-top: 0; background: #fff; box-shadow: -1px 1px 3px rgba(0,0,0,.1);

            /* core styles should not be changed */
            position: absolute; display: none; z-index: 9999; max-height: 254px; overflow: hidden; overflow-y: auto; box-sizing: border-box;
        }
        .autocomplete-suggestion { position: relative; padding: 0 .6em; line-height: 23px; white-space: nowrap; overflow: hidden; font-size: 1.02em; color: #333; }
        .autocomplete-suggestion b { font-weight: normal; color: #1f8dd6; }
        .autocomplete-suggestion.selected { background: #f0f0f0; }
  </style>
</head>

<body>
  <div class="left-top">
    <header>
      <h1>Bay Area Stats</h1>
    </header>
    <form id="control-form" name="control-form">
      <select id="stat-list" >
        <option value="0">Income</option>
        <option value="1">Race/Ethnicity</option>
      </select>
      <select id="race-list" class="hidden"></select> 
      <select id="asian-list" class="hidden"></select> <br>
      <input id="select-input" type="text" placeholder="City or Zip Code">
      <button id="select-button" type="button">Select</button>
    </form>
    <div class="tooltip">
        <div class="tip-location"></div>
      <div id="tip-container hidden">
        <div class="tip-info"></div>
        <h6 class="tip-description hidden"></h6>
      </div>
    </div>
    <div class="legend-container">
        <h5>Map Legend</h5>
        <small class="legend-description"></small>
        <div id="legend"></div>
    </div>
  </div>
  <div class="right-side"></div>

  <script type="text/javascript">


  (function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LabeledPie = factory();
  }
  }(this, function () {

    var LabeledPie = function(parent) {

        var svg = d3.select(parent)
            .append("svg")
            .append("g");

        this.svg = svg;

        this.svgWidth = 450;
        this.svgHeight = 190;

        d3.select(parent).select("svg").attr("width", this.svgWidth).attr("height", this.svgHeight);

        this.svg.append("g")
            .attr("class", "slices");
        this.svg.append("g")
            .attr("class", "labels");
        this.svg.append("g")
            .attr("class", "innerLabels");
        this.svg.append("g")
            .attr("class", "lines");

        this.width = 160,
        this.height = 160;
        this.radius = Math.min(this.width, this.height) / 2;

        this.pie = d3.layout.pie()
            .sort(null);

        this.arc = d3.svg.arc()
            .outerRadius(this.radius * 0.8)
            .innerRadius(this.radius * 0.4);

        this.outerArc = d3.svg.arc()
            .innerRadius(this.radius * 0.85)
            .outerRadius(this.radius * 0.85);

        this.edgeArc = d3.svg.arc()
            .innerRadius(this.radius * 0.8)
            .outerRadius(this.radius * 0.8);

        this.minimumDisplayedPercentage = 6;

        this.svg.attr("transform", "translate(" + this.svgWidth/2 + "," + this.svgHeight/2 + ")");

        this.minimumDisplayedLabel = 3;

        function pointToArray(point) {
            return [point.x, point.y];
        }

        function transitionLine(index, oldY, newY) {
            var delta = newY - oldY;
            var points;
            var pt0;
            var pt1;
            var pt2;
            var lineElement;
            svg.select(".lines").selectAll("polyline").each(function(d,i) {
                if (i === index) {
                    lineElement = this;
                }
            });
            points = lineElement.points;
            pt0 = pointToArray(points.getItem(0));
            pt1 = pointToArray(points.getItem(1));
            pt2 = pointToArray(points.getItem(2));

            d3.select(lineElement)
                .transition().duration(500)
                .attrTween("points", function(d){
                    return function(t) {
                        pt1[1] = oldY + t * delta;
                        pt2[1] = oldY + t * delta;
                        return [pt0, pt1, pt2];
                    };          
                });
        }

        function transitionOverlappingLabel(textElement, newY) {
            var matrix = textElement.transform.baseVal[0].matrix;
            var oldY = matrix.f;
            var pos = [matrix.e, matrix.f];
            var delta = newY - oldY;

            d3.select(textElement)
                .transition().duration(500)
                .attrTween("transform", function(d) {
                    return function(t) {
                        pos[1] = oldY + t * delta;
                        return "translate("+ pos +")";
                    };
                });
        }

        function adjustOverlappingLabels(labels) {
            var lastY = Infinity;  // matrix.f is y
            var matrix;
            var currentY;
            for (var i = 0; i < labels.length; i++ ) {
                matrix = labels[i].transform.baseVal[0].matrix;
                currentY = matrix.f;
                var height = labels[i].getBBox().height;
                if (currentY > (lastY - height)) {
                    currentY = lastY - height;
                    transitionOverlappingLabel(labels[i], currentY);
                    transitionLine(+labels[i].dataset.index, matrix.f, currentY);
                }
                lastY = currentY;
            }
        }

        function getOverlappingLabels() {
            var leftLabels = [];
            var rightLabels = [];

            svg.select(".labels").selectAll("text").each(function(d, index) {
                var str = this.outerHTML;
                if (!str.match("opacity: 0")) {  // only look at visible labels
                    this.dataset.index = index;
                    if (str.match("text-anchor: end")) {
                        leftLabels.push(this);
                    } else {
                        rightLabels.push(this);
                    }
                }
            });
            adjustOverlappingLabels(leftLabels);
            adjustOverlappingLabels(rightLabels.reverse());
            return true;  // return true to stop timer from firing again
        }

         
        LabeledPie.prototype.setLabels = function(labels) {
            this.labels = labels;
        }

        LabeledPie.prototype.setColorScale = function(color) {
            this.color = color;
        }



         LabeledPie.prototype.change = function(data) {

            var radius = this.radius;
            var labels = this.labels;
            var minimumDisplayedPercentage = this.minimumDisplayedPercentage;
            var arc = this.arc;
            var outerArc = this.outerArc;
            var edgeArc = this.edgeArc;
            var svg = this.svg;
            var pie = this.pie;
            var color = this.color;
            var minimumDisplayedLabel = this.minimumDisplayedLabel;


            var sum = d3.sum(data);

            function getPercentage(d) {
                return Math.round(d.value/sum*100);
            }

            function getTitle(d, i) {
              return labels[i] + ": " + d.value + ", " + getPercentage(d);
            }

            /* ------- PIE SLICES -------*/
            var slice = svg.select(".slices").selectAll("path.slice")
                .data(pie(data));

            slice.enter()
                .insert("path")
                .style("fill", function(d, i) { return color(i); })
                .attr("class", "slice");

        /*
            slice.append("svg:title")
                   .text(function(d, i) { 
                    return getTitle(d, i); })
        */

            slice       
                .transition().duration(1000)
                .attrTween("d", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        return arc(interpolate(t));
                    };
                })

            slice.exit()
                .remove();

            /* ------- TEXT LABELS -------*/

            var text = svg.select(".labels").selectAll("text")
                .data(pie(data));

            text.enter()
                .append("text")
                .attr("dy", ".35em")
                .text(function(d, i) {
                    return labels[i];
                });
            
            function midAngle(d){
                return d.startAngle + (d.endAngle - d.startAngle)/2;
            }

            text.transition().duration(1000)
               .style("opacity", function(d) {
                    return getPercentage(d) < minimumDisplayedLabel ? 0 : 1;
                })
                .attrTween("transform", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                        return "translate("+ pos +")";
                    };
                })
                .styleTween("text-anchor", function(d){
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        return midAngle(d2) < Math.PI ? "start":"end";
                    };
                });

            text.exit()
                .remove();

                d3.timer(getOverlappingLabels, 1000);


            /* ------- SLICE TO TEXT POLYLINES -------*/

            var polyline = svg.select(".lines").selectAll("polyline")
                .data(pie(data));
            
            polyline.enter()
                .append("polyline");

            polyline.transition().duration(1000)
                .style("opacity", function(d) {
                    return getPercentage(d) < minimumDisplayedLabel ? 0 : 0.3;
                })
                .attrTween("points", function(d){
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
                        return [edgeArc.centroid(d2), outerArc.centroid(d2), pos];
                    };          
                });
            
            polyline.exit()
                .remove();

        /* ------- PERCENTAGE LABELS -------*/

            var percent = svg.select(".innerLabels").selectAll("text")
                .data(pie(data));

            percent.enter()
                .insert("text")
                .attr("dy", ".35em");

            percent.transition().duration(1000)
            /*
                .tween("text", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var percent = getPercentage(d2);
                        this.textContent = percent > minimumDisplayedPercentage ? Math.round(percent) + "%" : "";

                    };
                })
  */
               .text(function(d) {
                    var percent = getPercentage(d);
                    return percent > minimumDisplayedPercentage ? Math.round(percent) + "%" : "";
                })
               .style("opacity", function(d) {
                    return d.value/sum*100 > minimumDisplayedPercentage ? 1 : 0;
                })
                .attrTween("transform", function(d, i) {
                    var bbox = this.getBBox();
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = arc.centroid(d2);
                        pos[0] = pos[0] - bbox.width/2;
                        //pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                        return "translate("+ pos +")";
                    };
                });

            percent.exit()
                .remove();


        };
    };

    return LabeledPie;
  }));

  


  </script> <script type="text/javascript">


  var incomePie = new LabeledPie(".tip-info");


  var statLabels = {
    race: ["All", "Latino", "White", "African American", "Native American", "Asian", 
      "Pacific Islander", "Other Race", "Mixed Race"],
    asian: ["All", "Asian Indian", "Bangladeshi", "Cambodian", "Mainland Chinese", "Filipino", "Hmong",
      "Japanese", "Korean", "Laotian", "Pakistani", "Taiwanese", "Thai", "Vietnamese"]
  }

  var pieLabelConfig = {
    income: {
      labels: ["< $25K", "$25K - $50K", "$50K - $75K", "$75K - $100K", "$100K - $200K", "> $200K"],
      domain: [0,1,2,3,4,5],
      range: ["#a50026","#f46d43","#fee08b","#d9ef8b","#66bd63","#006837"]
    },
    race: {
      labels: statLabels.race.slice(1),
      domain: [0,1,2,3,4,5, 6, 7],
      range: ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666"]
    },
    asian: {
      labels: statLabels.asian.slice(1),
      domain: [0,1,2,3,4,5, 6, 7, 8, 9, 10, 11, 12],
      range:["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928", "#cccccc"]
    }
  }


  var setPieLabels = function(labelConfig, key) {

    // reset income pie
    d3.select(".tip-info").select("svg").remove();
    incomePie = new LabeledPie(".tip-info");

    var color = d3.scale.ordinal()
      .domain(labelConfig[key]["domain"])
      .range(labelConfig[key]["range"]);

    incomePie.setLabels(labelConfig[key]["labels"]);
    incomePie.setColorScale(color);

  };

    var setLegendDescription = function(statType, statIndex) {

    var mapLegends = {
        income: "Percentage of income tax returns with AGI greater than $200,000",
        race: "Percentage of # race/ethnicity",
        asian: "Percentage of Asians listed as #"
    }

    var pieLegends = {
        income: "AGI reported on 2012 income tax return",
        race: "Race/Ethnicity",
        asian: "National origin of Asians"
    }

    var description = mapLegends[statType];
    if (description.indexOf('#') >= 0) {
       description = description.replace('#', statLabels[statType][statIndex]); 
    }  
    d3.select(".legend-description").text(description);
    d3.select(".tip-description").text(pieLegends[statType]);
  }

  var createComboBoxes = function() {
    raceList = statLabels.race.slice(1);
    var races = d3.select("#race-list").selectAll('option')
       .data(raceList);

    races.enter().append('option')
       .attr('value', function(d, i) {
          return i + 1;
       })
       .text(function(d) {
         return d;
       });

    var asians = d3.select("#asian-list").selectAll('option')
      .data(statLabels.asian);

    asians.enter().append('option')
      .attr('value', function(d,i) { return i; })
      .text(function(d) {
        return d;
      });

  }

  createComboBoxes();

  var createLegend = function(colors, statType, statIndex) {
    var formats = {
        percent: d3.format('%'),
        percentPointOne: d3.format('2.1%')
    };

    d3.select("#legend ul").remove();
    var legend = d3.select('#legend')
      .append('ul')
      .attr('class', 'list-inline');

    var keys = legend.selectAll('li.key')
        .data(colors.range());

    // do we need more precision?
    var endRange = colors.range()[colors.range().length - 1];
    var maxDomain = colors.invertExtent(endRange);
    var needMorePrecision = maxDomain[0] < 0.1;

    keys.enter().append('li')
        .attr('class', 'key')
        .style('border-top-color', String)
        .text(function(d) {
            var r = colors.invertExtent(d);
            return needMorePrecision ? 
              formats.percentPointOne(r[0]) : formats.percent(r[0]);
        });
    setLegendDescription(statType, statIndex);
  }


        var zipCodeMap = (function(createLegend, setPieLabels) {
            var width = 650;
            var height = 1000;

var projection = d3.geo.albersUsa()
    .scale(0.6 * (1 << 16))
    .translate([width / 2, height / 2]);

var path = d3.geo.path()
    .projection(projection);

var zoom = d3.behavior.zoom()
    .translate(projection.translate())
    .scale(projection.scale())
    .scaleExtent([0.6 * (1 << 16), 0.7*(1 << 17)])
    .on("zoom", zoomed);
                             
            //Define quantize scale to sort data values into buckets of color
            var color = d3.scale.quantize()
                                .range(["#a50026","#d73027","#f46d43","#fdae61","#fee08b","#ffffbf","#d9ef8b","#a6d96a","#66bd63","#1a9850","#006837"]);

            //Create SVG element
            var svg = d3.select(".right-side")
                        .append("svg")
                        .attr("width", width)
                        .attr("height", height)
                        .call(zoom);

            var statIndex = 6;  

            var statType = "income";

            var statData;

            var geometry;

            var getPropertyValues = function() {
                var key;
                var valueMap = {};
                var zips = topojson.feature(geometry, geometry.objects.Bay_Area);
                zips.features.forEach(function(d) {
                    for (key in d.properties) {
                        valueMap[d.properties[key]] = true;
                    }
                });
                return Object.keys(valueMap);
            }

            var setStatType = function(newStatType) {
                statType = newStatType;
            }

            var setStatIndex = function(newStatIndex) {
                statIndex = newStatIndex;
            };

            function getStatValue(d, stats) {
                    var zip = d.properties.GEOID10;
                    var counts = stats[zip][statType];
                    if (counts) {
                        /*  CHANGE THIS FOR EACH RACE/INCOME LEVEL */
                        return +counts[statIndex]/+counts[0];

                    } else {
                        return null;
                    }
                
                }   

            function getTitle(d) { 
                            return d.properties.GEOID10 + ": " + d.properties.city;
                }

            function setToolTip(d, stats, values) {
                    values = values || stats[d.properties.GEOID10][statType];
                    var counts = values.slice(1);
                    if (+values[0] > 0) {
                        d3.select(".tip-info").classed("hidden", false);
                        d3.select(".tip-description").classed("hidden", false);
                       incomePie.change(counts);
                    } else {
                        d3.select(".tip-info").classed("hidden", true);
                        d3.select(".tip-description").classed("hidden", false);
                    }
                }   

            var updateColorDomain = function() {
                var zips = topojson.feature(geometry, geometry.objects.Bay_Area)

/*                var min = d3.min(zips.features, function(d) { 
                        return getStatValue(d, statData); //+d.properties.GEOID10; 
                    });
                    var max = d3.max(zips.features, function(d) { 
                        return getStatValue(d, statData); //+d.properties.GEOID10;
                     })


                color.domain([
                  min, 
                  max
                  ]);  
*/
                color.domain(
                    d3.extent(zips.features, function(d) { 
                        return getStatValue(d, statData); })
                );

                createLegend(color, statType, statIndex); 

            }

            var updateStats = function() {

                updateColorDomain()

                svg.selectAll("path")
                       .transition().duration(1000)
                       .attr("fill", function(d) {
                            //Get data value
                            var value = getStatValue(d, statData); 
                            
                            if (value) {
                                //If value exists…
                                return color(value);
                            } else {
                                //If value is undefined…
                                return "#ccc";
                            }
                       })

            };

            var selectByData = function(field, fieldValue) {
                var matches = [];
                var aggregate = [];
                var title;
                var zip;
                var values;

                var zips = topojson.feature(geometry, geometry.objects.Bay_Area);
                zips.features.forEach(function(d) {
                    if (d.properties[field] === fieldValue) {
                        matches.push(d);
                    }
                });
                if (matches.length > 0) {
                    d3.selectAll(".selected").classed("selected", false);
                    matches.forEach(function(d) {
                        zip = d.properties.GEOID10;
                        values = statData[zip][statType];
                        for (var i = 0; i < values.length; i++) {
                            aggregate[i] = aggregate[i] || 0;
                            aggregate[i] += +values[i];
                        }
                    });
                    title = (matches.length > 1) ? fieldValue : getTitle(matches[0]);
                    d3.select(".tip-location").text(title);
                    setToolTip(null, statData, aggregate);
                }

                svg.selectAll("path")[0].forEach(function(path) {
                    var path = d3.select(path);
                    if (path.datum().properties[field] === fieldValue) {
                        path.classed("selected", true);
                    }
                });

                if (matches.length > 0) {
                    aggregate = matches[0];

                    center(aggregate, true);
                }
            }

            function centerZip(ba) {

  var zips = topojson.feature(ba, ba.objects.Bay_Area),
      zip = zips.features.filter(function(d) { 

        return d.properties.GEOID10 === "94560";
         })[0];

  center(zip);
}


function center(d, transition) {
  var centroid = path.centroid(d),
      translate = projection.translate();

  projection.translate([
    translate[0] - centroid[0] + width / 2,
    translate[1] - centroid[1] + height / 2
  ]);

  zoom.translate(projection.translate());

    if (transition) {
      svg.selectAll("path").transition()
          .duration(1000)
          .attr("d", path);
    } else {
      svg.selectAll("path")
          .attr("d", path); 
    }   
}

function zoomed() {
  projection.translate(d3.event.translate).scale(d3.event.scale);
  svg.selectAll("path").attr("d", path);
}

            d3.json("data/allStats.json", function(stats) {
                statData = stats;

                d3.json("Bay_Area_Cities_topo.json", function(json) {
                    geometry = json;
                    var lastZipClick = [];
                    updateColorDomain();

                    svg.selectAll("path")
                       .data(topojson.feature(json, json.objects.Bay_Area).features)
                       .enter()
                       .append("path")
                       .attr("d", path)
                       .attr("stroke", "black")
                       .attr("fill", function(d) {
                            //Get data value
                            var value = getStatValue(d, statData); 
                            
                            if (value) {
                                //If value exists…
                                return color(value);
                            } else {
                                //If value is undefined…
                                return "#ccc";
                            }
                       })
                       .on("click", function (d) {
                            // Find previously selected, unselect
                            d3.selectAll(".selected").classed("selected", false);

                            // Select current item
                            d3.select(this).classed("selected", true);
                            d3.select(".tip-location").text(getTitle(d));
                            setToolTip(d, statData);
                            lastZipClick = [d3.event.x, d3.event.y];
                        })
                       .append("svg:title")
                           .text(function(d) { 
                            return getTitle(d); });
                     

                     centerZip(json);      

                     d3.select(".right-side").on("click", function() {
                        if (d3.event.x !== lastZipClick[0]  && d3.event.y !== lastZipClick[1]) {
                          d3.select(".selected").classed("selected", false);
                          d3.select(".tip-info").classed("hidden", true);
                          d3.select(".tip-description").classed("hidden", true);
                          d3.select(".tip-location").text('');
                       }
                       lastZipClick = [];
                     })
            });
        });

       setPieLabels(pieLabelConfig, "income");

       return {
          getPropertyValues: getPropertyValues,
          setStatType: setStatType,
          setStatIndex: setStatIndex,
          updateStats: updateStats,
          selectByData: selectByData
       }
  })(createLegend, setPieLabels);


  





  var getSelectionTitle = function() {
    var retVal = d3.select(".tip-location").text().split(':')[0];
    return retVal;
  }

  var selectByData = function(value) {
    var key = value.match(/[0-9]/) ? "GEOID10" : "city";
    zipCodeMap.selectByData(key, value);
  }

  d3.select("#stat-list")
    .on("change", function() {
      var statIndex = +d3.select("#stat-list").node().value;
      var raceIndex = +d3.select("#race-list").node().value;
      d3.select("#race-list").classed("hidden", statIndex === 0);
      d3.select("#asian-list").classed("hidden", statIndex === 0 || raceIndex !== 5);
      if (statIndex === 0) {
        zipCodeMap.setStatType("income");
        zipCodeMap.setStatIndex(6);
        setPieLabels(pieLabelConfig, "income");
        selectByData(getSelectionTitle());
      } else if (statIndex === 1) {
        zipCodeMap.setStatType("race");
        zipCodeMap.setStatIndex(raceIndex);
        setPieLabels(pieLabelConfig, "race");
        selectByData(getSelectionTitle());
      }
      zipCodeMap.updateStats();
    });

  d3.select("#race-list")
    .on("change", function() {
      var raceIndex = +d3.select("#race-list").node().value;
      d3.select("#asian-list").classed("hidden", raceIndex !== 5);
      var asianIndex = +d3.select("#asian-list").node().value;
      if (raceIndex === 5) {
        selectAsian();
      } else {
          zipCodeMap.setStatType("race");
          zipCodeMap.setStatIndex(raceIndex);
          setPieLabels(pieLabelConfig, "race");
          selectByData(getSelectionTitle());
      }
      zipCodeMap.updateStats();
    });  

  var selectAsian = function() {
    var asianIndex = +d3.select("#asian-list").node().value;
    if (asianIndex === 0) {
      zipCodeMap.setStatType("race");
      zipCodeMap.setStatIndex(5);
      setPieLabels(pieLabelConfig, "race");
      selectByData(getSelectionTitle());
    } else {
      zipCodeMap.setStatType("asian");
      zipCodeMap.setStatIndex(asianIndex);
      setPieLabels(pieLabelConfig, "asian");
      selectByData(getSelectionTitle());
    }
  }

  d3.select("#asian-list")
    .on("change", function() {
      selectAsian();
      zipCodeMap.updateStats();
    });

  d3.select("#select-button")
    .on("click", function() {
        window.event.stopPropagation();
        var value = d3.select("#select-input").node().value;
        var key = value.match(/[0-9]/) ? "GEOID10" : "city";
        zipCodeMap.selectByData(key, value); //GEOID10
    })

  /*d3.select("#select-input")
    .on("keyup", function(){
      window.event.stopPropagation();
      var value = d3.select("#select-input").node().value;
      var key = value.match(/[0-9]/) ? "GEOID10" : "city";
      zipCodeMap.selectByData(key, value); //GEOID10

    });*/

  $("#select-input")
    .on("propertychange", function(){
      window.event.stopPropagation();
      var value = d3.select("#select-input").node().value;
      var key = value.match(/[0-9]/) ? "GEOID10" : "city";
      zipCodeMap.selectByData(key, value); //GEOID10

    });


  $("#select-input").bind('input propertychange', function(event) {
    event.stopPropagation();
    var value = d3.select("#select-input").node().value;
    var key = value.match(/[0-9]/) ? "GEOID10" : "city";
    zipCodeMap.selectByData(key, value);      
  });

  $("#select-input").on('val.changed', function(event) {
    event.stopPropagation();
    var value = d3.select("#select-input").node().value;
    var key = value.match(/[0-9]/) ? "GEOID10" : "city";
    zipCodeMap.selectByData(key, value);      
  });


   // hack to get auto-complete programmatic change to #select-input noticed
   (function($){
    var originalVal = $.fn.val;
    $.fn.val = function(){
        var result =originalVal.apply(this,arguments);
        if(arguments.length>0)
            $(this).trigger('val.changed');
        return result;
    };
  })(jQuery);

  $("#select-input").autoComplete({
    minChars: 1,
    source: function(term, suggest){
        term = term.toLowerCase();
        var choices = zipCodeMap.getPropertyValues();
        var matches = [];
        for (i=0; i<choices.length; i++)
            if (~choices[i].toLowerCase().indexOf(term)) matches.push(choices[i]);
        suggest(matches);
    }
  });  

                
            
  </script>
</body>
</html>