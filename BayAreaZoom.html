<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>D3: Bay Area Income by Zip Code</title>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <style type="text/css">

         header, #controlForm {
          border: solid 1px;
         }
         text {
            color: black;
            fill: black;
            font-size: 12px;
            font-family: sans-serif;
            width: 50px;
            height: 14px;
           }

           h1 {
             text-align: center;
             font-family: sans-serif;
           }


            path:hover {
                fill: lightskyblue;
            }
            .selected {
                fill: blue;
            }
            #controlForm {
                padding: 15px;
            } 
            #statList {
            	margin-bottom: 10px;
            }  
            .tt {
                /*position: absolute;*/
                opacity: 0.95;
                background-color: white;
                border: 3px;
                border-color: gray;
                margin-top: 10px;
                
            }
            #tipInfo {
                width: 450;
                height: 360;
                padding: 10px;
            }
            #tipLocation {
                color: white;
                background-color: #006837;
                font-family: 'Roboto Condensed', sans-serif;
                font-size: 1.8em;
                padding: 7px;
                text-align: center;

            }
            .hidden {
                visibility: hidden;
            }


             /*   Pie styling */
            .labels {
                font-size: 10px;
            }

            .innerLabels text {
                font-size: 10px;
                fill: white;
            }
            path.slice{
                stroke-width:2px;
            }

            polyline{
                opacity: .3;
                stroke: black;
                stroke-width: 2px;
                fill: none;
            }
            .leftTop {
                position: fixed;
                z-index: 130;
                top: 0px;
                left: 0px;
                width: 450px;
            }
            .rightSide {
                position:absolute;
                top: 0px;
                left: 450px;
                overflow: scroll;
            }
            .tipInfo svg {
                width: 450;
                height: 300;
            }
  </style>
</head>

<body>
  <div class="leftTop">
    <header>
      <h1>Bay Area Stats</h1>
    </header>

    <form id="controlForm" name="controlForm">
      <select id="statList" >
        <option value="0">
          Income
        </option>

        <option value="1">
          Race/Ethnicity
        </option>
      </select> <select id="raceList" class="hidden">
        <option value="1">
          Latino
        </option>

        <option value="2">
          White
        </option>

        <option value="3">
          African American
        </option>

        <option value="4">
          Native American
        </option>

        <option value="5">
          Asian
        </option>

        <option value="6">
          Pacific Islander
        </option>

        <option value="7">
          Other Race
        </option>

        <option value="8">
          Mixed Race
        </option>
      </select> <select id="asianList" class="hidden">
        <option value="0">
          All
        </option>

        <option value="1">
          Asian Indian
        </option>

        <option value="2">
          Bangladeshi
        </option>

        <option value="3">
          Cambodian
        </option>

        <option value="4">
          Mainland Chinese
        </option>

        <option value="5">
          Filipino
        </option>

        <option value="6">
          Hmong
        </option>

        <option value="7">
          Japanese
        </option>

        <option value="8">
          Korean
        </option>

        <option value="9">
          Laotian
        </option>

        <option value="10">
          Pakistani
        </option>

        <option value="11">
          Taiwanese
        </option>

        <option value="12">
          Thai
        </option>

        <option value="13">
          Vietnamese
        </option>
      </select> <br>
      <input id="selectInput" type="text" placeholder="City or Zip Code"> <button id="selectButton" type=
      "button">Select</button>
    </form>

    <div class="tooltip hidden" id="tt">
      <div id="tipContainer">
        <div id="tipLocation"></div>

        <div id="tipInfo"></div>
      </div>
    </div>
  </div>

  <div class="rightSide"></div><script type="text/javascript">


  (function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LabeledPie = factory();
  }
  }(this, function () {

    var LabeledPie = function(parent) {

        var svg = d3.select(parent)
            .append("svg")
            .append("g");

        this.svg = svg;

        d3.select(parent).select("svg").attr("width", "450").attr("height", "320");

        this.svg.append("g")
            .attr("class", "slices");
        this.svg.append("g")
            .attr("class", "labels");
        this.svg.append("g")
            .attr("class", "innerLabels");
        this.svg.append("g")
            .attr("class", "lines");

        this.width = 160,
        this.height = 160;
        this.radius = Math.min(this.width, this.height) / 2;

        this.pie = d3.layout.pie()
            .sort(null);

        this.arc = d3.svg.arc()
            .outerRadius(this.radius * 0.8)
            .innerRadius(this.radius * 0.4);

        this.outerArc = d3.svg.arc()
            .innerRadius(this.radius * 0.85)
            .outerRadius(this.radius * 0.85);

        this.edgeArc = d3.svg.arc()
            .innerRadius(this.radius * 0.8)
            .outerRadius(this.radius * 0.8);

        this.minimumDisplayedPercentage = 6;

        this.svg.attr("transform", "translate(" + 195 + "," + 110 + ")");

        this.minimumDisplayedLabel = 3;

        function pointToArray(point) {
            return [point.x, point.y];
        }

        function transitionLine(index, oldY, newY) {
            var delta = newY - oldY;
            var points;
            var pt0;
            var pt1;
            var pt2;
            var lineElement;
            svg.select(".lines").selectAll("polyline").each(function(d,i) {
                if (i === index) {
                    lineElement = this;
                }
            });
            points = lineElement.points;
            pt0 = pointToArray(points.getItem(0));
            pt1 = pointToArray(points.getItem(1));
            pt2 = pointToArray(points.getItem(2));

            d3.select(lineElement)
                .transition().duration(500)
                .attrTween("points", function(d){
                    return function(t) {
                        pt1[1] = oldY + t * delta;
                        pt2[1] = oldY + t * delta;
                        return [pt0, pt1, pt2];
                    };          
                });
        }

        function transitionOverlappingLabel(textElement, newY) {
            var matrix = textElement.transform.baseVal[0].matrix;
            var oldY = matrix.f;
            var pos = [matrix.e, matrix.f];
            var delta = newY - oldY;

            d3.select(textElement)
                .transition().duration(500)
                .attrTween("transform", function(d) {
                    return function(t) {
                        pos[1] = oldY + t * delta;
                        return "translate("+ pos +")";
                    };
                });
        }

        function adjustOverlappingLabels(labels) {
            var lastY = Infinity;  // matrix.f is y
            var matrix;
            var currentY;
            for (var i = 0; i < labels.length; i++ ) {
                matrix = labels[i].transform.baseVal[0].matrix;
                currentY = matrix.f;
                var height = labels[i].getBBox().height;
                if (currentY > (lastY - height)) {
                    currentY = lastY - height;
                    transitionOverlappingLabel(labels[i], currentY);
                    transitionLine(+labels[i].dataset.index, matrix.f, currentY);
                }
                lastY = currentY;
            }
        }

        function getOverlappingLabels() {
            var leftLabels = [];
            var rightLabels = [];

            svg.select(".labels").selectAll("text").each(function(d, index) {
                var str = this.outerHTML;
                if (!str.match("opacity: 0")) {  // only look at visible labels
                    this.dataset.index = index;
                    if (str.match("text-anchor: end")) {
                        leftLabels.push(this);
                    } else {
                        rightLabels.push(this);
                    }
                }
            });
            adjustOverlappingLabels(leftLabels);
            adjustOverlappingLabels(rightLabels.reverse());
            return true;  // return true to stop timer from firing again
        }

         
        LabeledPie.prototype.setLabels = function(labels) {
            this.labels = labels;
        }

        LabeledPie.prototype.setColorScale = function(color) {
            this.color = color;
        }



         LabeledPie.prototype.change = function(data) {

            var radius = this.radius;
            var labels = this.labels;
            var minimumDisplayedPercentage = this.minimumDisplayedPercentage;
            var arc = this.arc;
            var outerArc = this.outerArc;
            var edgeArc = this.edgeArc;
            var svg = this.svg;
            var pie = this.pie;
            var color = this.color;
            var minimumDisplayedLabel = this.minimumDisplayedLabel;


            var sum = d3.sum(data);

            function getPercentage(d) {
                return Math.round(d.value/sum*100);
            }

            function getTitle(d, i) {
              return labels[i] + ": " + d.value + ", " + getPercentage(d);
            }

            /* ------- PIE SLICES -------*/
            var slice = svg.select(".slices").selectAll("path.slice")
                .data(pie(data));

            slice.enter()
                .insert("path")
                .style("fill", function(d, i) { return color(i); })
                .attr("class", "slice");

        /*
            slice.append("svg:title")
                   .text(function(d, i) { 
                    return getTitle(d, i); })
        */

            slice       
                .transition().duration(1000)
                .attrTween("d", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        return arc(interpolate(t));
                    };
                })

            slice.exit()
                .remove();

            /* ------- TEXT LABELS -------*/

            var text = svg.select(".labels").selectAll("text")
                .data(pie(data));

            text.enter()
                .append("text")
                .attr("dy", ".35em")
                .text(function(d, i) {
                    return labels[i];
                });
            
            function midAngle(d){
                return d.startAngle + (d.endAngle - d.startAngle)/2;
            }

            text.transition().duration(1000)
               .style("opacity", function(d) {
                    return getPercentage(d) < minimumDisplayedLabel ? 0 : 1;
                })
                .attrTween("transform", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                        return "translate("+ pos +")";
                    };
                })
                .styleTween("text-anchor", function(d){
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        return midAngle(d2) < Math.PI ? "start":"end";
                    };
                });

            text.exit()
                .remove();

                d3.timer(getOverlappingLabels, 1000);


            /* ------- SLICE TO TEXT POLYLINES -------*/

            var polyline = svg.select(".lines").selectAll("polyline")
                .data(pie(data));
            
            polyline.enter()
                .append("polyline");

            polyline.transition().duration(1000)
                .style("opacity", function(d) {
                    return getPercentage(d) < minimumDisplayedLabel ? 0 : 0.3;
                })
                .attrTween("points", function(d){
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
                        return [edgeArc.centroid(d2), outerArc.centroid(d2), pos];
                    };          
                });
            
            polyline.exit()
                .remove();

        /* ------- PERCENTAGE LABELS -------*/

            var percent = svg.select(".innerLabels").selectAll("text")
                .data(pie(data));

            percent.enter()
                .insert("text")
                .attr("dy", ".35em");

            percent.transition().duration(1000)
            /*
                .tween("text", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var percent = getPercentage(d2);
                        this.textContent = percent > minimumDisplayedPercentage ? Math.round(percent) + "%" : "";

                    };
                })
  */
               .text(function(d) {
                    var percent = getPercentage(d);
                    return percent > minimumDisplayedPercentage ? Math.round(percent) + "%" : "";
                })
               .style("opacity", function(d) {
                    return d.value/sum*100 > minimumDisplayedPercentage ? 1 : 0;
                })
                .attrTween("transform", function(d, i) {
                    var bbox = this.getBBox();
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = arc.centroid(d2);
                        pos[0] = pos[0] - bbox.width/2;
                        //pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                        return "translate("+ pos +")";
                    };
                });

            percent.exit()
                .remove();


        };



    };

    return LabeledPie;
  }));

  var incomePie = new LabeledPie("#tipInfo");

  var setPieLabels = function(labelConfig, key) {

    // reset income pie
    d3.select("#tipInfo").select("svg").remove();
    incomePie = new LabeledPie("#tipInfo");

    var color = d3.scale.ordinal()
      .domain(labelConfig[key]["domain"])
      .range(labelConfig[key]["range"]);

    incomePie.setLabels(labelConfig[key]["labels"]);
    incomePie.setColorScale(color);

  };

   /*
  (function () {

    var labels = ["Latino", "White", "African American", "Native", "Asian", 
      "Pacific Islander", "Other Race", "Mixed Race"];

    var color = d3.scale.ordinal()
      .domain([0,1,2,3,4,5, 6, 7])
      .range(["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666"]);

    incomePie.setLabels(labels);
    incomePie.setColorScale(color);
        
  })();
  */

  /*
  (function () {

    var labels = ["< $25K", "$25K - $50K", "$50K - $75K", "$75K - $100K", "$100K - $200K", "> $200K"];

    var color = d3.scale.ordinal()
      .domain([0,1,2,3,4,5])
      .range(["#a50026","#f46d43","#fee08b","#d9ef8b","#66bd63","#006837"]);

    incomePie.setLabels(labels);
    incomePie.setColorScale(color);
        
  })();

  */

  var pieLabelConfig = {
    income: {
      labels: ["< $25K", "$25K - $50K", "$50K - $75K", "$75K - $100K", "$100K - $200K", "> $200K"],
      domain: [0,1,2,3,4,5],
      range: ["#a50026","#f46d43","#fee08b","#d9ef8b","#66bd63","#006837"]
    },
    race: {
      labels: ["Latino", "White", "African American", "Native", "Asian", 
      "Pacific Islander", "Other Race", "Mixed Race"],
      domain: [0,1,2,3,4,5, 6, 7],
      range: ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666"]
    },
    asian: {
      labels: ["Asian Indian", "Bangladeshi", "Cambodian", "Mainland Chinese", "Filipino", "Hmong",
      "Japanese", "Korean", "Laotian", "Pakistani", "Taiwanese", "Thai", "Vietnamese"],
      domain: [0,1,2,3,4,5, 6, 7, 8, 9, 10, 11, 12],
      range:["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928", "#cccccc"]
    }
  }


  </script> <script type="text/javascript">

        var zipCodeMap = (function() {

            //Width and height
            var width = 650;
            var height = 1000;

var projection = d3.geo.albersUsa()
    .scale(0.6 * (1 << 16))
    .translate([width / 2, height / 2]);

var path = d3.geo.path()
    .projection(projection);

var zoom = d3.behavior.zoom()
    .translate(projection.translate())
    .scale(projection.scale())
    .scaleExtent([0.6 * (1 << 16), 0.7*(1 << 17)])
    .on("zoom", zoomed);

// var svg = d3.select("body").append("svg")
//     .attr("width", width)
//     .attr("height", height);

// var g = svg.append("g")
//     .call(zoom);
                             
            //Define quantize scale to sort data values into buckets of color
            var color = d3.scale.quantize()
                                .range(["#a50026","#d73027","#f46d43","#fdae61","#fee08b","#ffffbf","#d9ef8b","#a6d96a","#66bd63","#1a9850","#006837"]);

            //Create SVG element
            var svg = d3.select(".rightSide")
                        .append("svg")
                        .attr("width", width)
                        .attr("height", height)
                        .call(zoom);

            var statIndex = 6;  

            var statType = "income";

            var statData;

            var geometry;

            var setStatType = function(newStatType) {
                statType = newStatType;
            }

            var setStatIndex = function(newStatIndex) {
                statIndex = newStatIndex;
            };

            function getStatValue(d, stats) {
                    var zip = d.properties.GEOID10;
                    var counts = stats[zip][statType];
                    if (counts) {
                        /*  CHANGE THIS FOR EACH RACE/INCOME LEVEL */
                        return +counts[statIndex]/+counts[0];

                    } else {
                        return null;
                    }
                
                }   

            function getTitle(d) { 
                            return d.properties.GEOID10 + ": " + d.properties.city;
                }

            function setToolTip(d, stats) {
                    d3.select(".tooltip").classed("hidden", false);
                    var zip = d.properties.GEOID10;
                    var counts = stats[zip][statType].slice(1);

                    incomePie.change(counts);
                }   

            var updateColorDomain = function() {
                var min = d3.min(geometry.features, function(d) { 
                        return getStatValue(d, statData); //+d.properties.GEOID10; 
                    });
                    var max = d3.max(geometry.features, function(d) { 
                        return getStatValue(d, statData); //+d.properties.GEOID10;
                     })


                color.domain([
                  min, 
                  max
                  ]);   

            }

            var updateStats = function() {

                updateColorDomain()

                svg.selectAll("path")
                       .transition().duration(1000)
                       .attr("fill", function(d) {
                            //Get data value
                            var value = getStatValue(d, statData); 
                            
                            if (value) {
                                //If value exists…
                                return color(value);
                            } else {
                                //If value is undefined…
                                return "#ccc";
                            }
                       })

            };

            var selectByData = function(field, fieldValue) {
                d3.selectAll(".selected").classed("selected", false);
                svg.selectAll("path")
                       .transition().duration(1000)
                       .attr("fill", function(d) {

                            if (d.properties[field] === fieldValue) {
                                d3.select(this).classed("selected", true);
                                d3.select("#tipLocation").text(getTitle(d))
                                setToolTip(d, statData);
                                clicked(d, true);
                            }
                            //Get data value
                            var value = getStatValue(d, statData); 
                            
                            if (value) {
                                //If value exists…
                                return color(value);
                            } else {
                                //If value is undefined…
                                return "#ccc";
                            }
                       })

            }

            function centerAndScale(ba) {

  var zips = topojson.feature(ba, ba.objects.Bay_Area),
      zip = zips.features.filter(function(d) { 

        return d.properties.GEOID10 === "94560";
         })[0];
  // // Create a unit projection.
  // var projection = d3.geo.albers()
  //     .scale(1)
  //     .translate([0, 0]);

  // // Create a path generator.
  // var path = d3.geo.path()
  //     .projection(projection);

  // // Compute the bounds of a feature of interest, then derive scale & translate.
  // var b = path.bounds(zip),
  //     s = .07 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
  //     t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];

  // // Update the projection to use computed scale & translate.
  // projection
  //     .scale(s)
  //     .translate(t);

  //     zoom.translate(projection.translate());

  // g.selectAll("path").transition()
  //     .duration(700)
  //     .attr("d", path);

  clicked(zip);
}


function clicked(d, transition) {
  var centroid = path.centroid(d),
      translate = projection.translate();

  projection.translate([
    translate[0] - centroid[0] + width / 2,
    translate[1] - centroid[1] + height / 2
  ]);

  zoom.translate(projection.translate());

    if (transition) {
      svg.selectAll("path").transition()
          .duration(1000)
          .attr("d", path);
    } else {
      svg.selectAll("path")
          .attr("d", path); 
    }   
}

function zoomed() {
  projection.translate(d3.event.translate).scale(d3.event.scale);
  svg.selectAll("path").attr("d", path);
}

            d3.json("data/allStats.json", function(stats) {
                statData = stats;


                //Load in GeoJSON data

                
                
                /*
                //   FOR IRS INCOME DATA
                function getStatValue(d, stats) {
                    var zip = d.properties.GEOID10;
                    var counts = stats[zip];
                    if (counts) {
                        return +counts[counts.length - 1]/+counts[0];

                    } else {
                        return null;
                    }
                
                }   
                */

    



                d3.json("Bay_Area_Cities_topo.json", function(json) {

                    geometry = json;

                    var lastZipClick = [];

                    var zips = topojson.feature(json, json.objects.Bay_Area)

                    var min = d3.min(zips.features, function(d) { 
                        return getStatValue(d, statData); //+d.properties.GEOID10; 
                    });
                    var max = d3.max(zips.features, function(d) { 
                        return getStatValue(d, statData); //+d.properties.GEOID10;
                     })


                    color.domain([
                      min, 
                      max
                      ]);   


                    svg.selectAll("path")
                       .data(topojson.feature(json, json.objects.Bay_Area).features)
                       .enter()
                       .append("path")
                       .attr("d", path)
                       .attr("stroke", "black")
                       .attr("fill", function(d) {
                            //Get data value
                            var value = getStatValue(d, statData); 
                            
                            if (value) {
                                //If value exists…
                                return color(value);
                            } else {
                                //If value is undefined…
                                return "#ccc";
                            }
                       })
                       .on("click", function (d) {
                            // Find previously selected, unselect
                            d3.select(".selected").classed("selected", false);

                            // Select current item
                            d3.select(this).classed("selected", true);
                            d3.select("#tipLocation").text(getTitle(d));
                            setToolTip(d, statData);
                            //console.log("x: " + d3.event.x + ", y: " + d3.event.y);
                            /*
                            d3.select('#tt')
                               .attr("style", "left: " + d3.event.x + "px; top: " + d3.event.y + "px;");*/
                            lastZipClick = [d3.event.x, d3.event.y];
                        })
                       .append("svg:title")
                           .text(function(d) { 
                            return getTitle(d); });
                     

                     centerAndScale(json);      

                     /*  TODO: find a way to unselect tooltip when selecting off a zip code region */       

                     d3.select(".rightSide").on("click", function() {
                        if (d3.event.x !== lastZipClick[0]  && d3.event.y !== lastZipClick[1]) {
                          d3.select(".selected").classed("selected", false);
                          d3.select(".tooltip").classed("hidden", true);
                       }
                       lastZipClick = [];
                     })
            
            });
        });

       setPieLabels(pieLabelConfig, "income");

       return {
          setStatType: setStatType,
          setStatIndex: setStatIndex,
          updateStats: updateStats,
          selectByData: selectByData
       }
  })();

  d3.select("#statList")
    .on("change", function() {
      var statIndex = +d3.select("#statList").node().value;
      var raceIndex = +d3.select("#raceList").node().value;
      d3.select("#raceList").classed("hidden", statIndex === 0);
      d3.select("#asianList").classed("hidden", statIndex === 0 || raceIndex !== 5);
      if (statIndex === 0) {
        zipCodeMap.setStatType("income");
        zipCodeMap.setStatIndex(6);
        setPieLabels(pieLabelConfig, "income");
      } else if (statIndex === 1) {
        zipCodeMap.setStatType("race");
        zipCodeMap.setStatIndex(raceIndex);
        setPieLabels(pieLabelConfig, "race");
      }
      zipCodeMap.updateStats();
    });

  d3.select("#raceList")
    .on("change", function() {
      var raceIndex = +d3.select("#raceList").node().value;
      d3.select("#asianList").classed("hidden", raceIndex !== 5);
      zipCodeMap.setStatType("race");
      zipCodeMap.setStatIndex(raceIndex);
      zipCodeMap.updateStats();
      setPieLabels(pieLabelConfig, "race");
    });  

  d3.select("#asianList")
    .on("change", function() {
        var statIndex = +d3.select("#asianList").node().value;
        if (statIndex === 0) {
          zipCodeMap.setStatType("race");
          zipCodeMap.setStatIndex(5);
          zipCodeMap.updateStats();
          setPieLabels(pieLabelConfig, "race");
        } else {
          zipCodeMap.setStatType("asian");
          zipCodeMap.setStatIndex(statIndex);
          zipCodeMap.updateStats();
          setPieLabels(pieLabelConfig, "asian");
        }
    });

  d3.select("#selectButton")
    .on("click", function() {
        window.event.stopPropagation();
        var value = d3.select("#selectInput").node().value;
        zipCodeMap.selectByData("city", value); //GEOID10
    })

  d3.select("#selectInput")
    .on("keyup", function(){
      window.event.stopPropagation();
      var value = d3.select("#selectInput").node().value;
      var key = value.match(/[0-9]/) ? "GEOID10" : "city";
      zipCodeMap.selectByData(key, value); //GEOID10

    });

  d3.select("#selectInput")
    .on("change", function(){
      window.event.stopPropagation();
      var value = d3.select("#selectInput").node().value;
      var key = value.match(/[0-9]/) ? "GEOID10" : "city";
      zipCodeMap.selectByData(key, value); //GEOID10

    });

                
            
  </script>
</body>
</html>