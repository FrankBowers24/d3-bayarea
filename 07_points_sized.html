<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>D3: Bay Area Income by Zip Code</title>
		<script type="text/javascript" src="../d3/d3.v3.js"></script>
		<style type="text/css">
		   text {
		   	color: black;
		   	fill: black;
		   	font-size: 12px;
		   	font-family: sans-serif;
		   	width: 50px;
		   	height: 14px;
		   }

		    path:hover {
				fill: lightskyblue;
			}
			.selected {
				fill: blue;
			}
			#controlForm {
				padding: 15px;
				margin: 15px;

			}	
			.tt {
				/*position: absolute;*/
				opacity: 0.95;
				background-color: white;
				border: 3px;
				border-color: gray;
				margin-top: 10px;
				
			}
			#tipInfo {
				width: 450;
				height: 360;
				padding: 10px;
			}
			#tipLocation {
				color: white;
				background-color: #006837;
				font-family: 'Roboto Condensed', sans-serif;
				font-size: 1.8em;
				padding: 7px;
				text-align: center;

			}
			.hidden {
				visibility: hidden;
			}


             /*   Pie styling */
			.labels {
				font-size: 10px;
			}

			.innerLabels text {
				font-size: 10px;
				fill: white;
			}
			path.slice{
				stroke-width:2px;
			}

			polyline{
				opacity: .3;
				stroke: black;
				stroke-width: 2px;
				fill: none;
			}
			.leftTop {
				position: absolute;
				z-index: 130;
				top: 0px;
				left: 0px;
				width: 450px;
			}
			.rightSide {
				position:absolute;
				top: 0px;
				left: 450px;
			}
			.tipInfo svg {
				width: 450;
				height: 300;
			}
		</style>
	</head>
	<body>
<div class="leftTop">
<div id="controlForm">
<select name="statType">
	<option value="0">Income</option>
	<option value="1">Race/Ethnicity</option>
</select>

<select id="raceList" >
  <option value="1">Latino</option>
  <option value="2">White</option>
  <option value="3">African American</option>
  <option value="4">Native American</option>
  <option value="5">Asian</option>
  <option value="6">Pacific Islander</option>
  <option value="7">Other Race</option>
  <option value="8">Mixed Race</option>
</select>


<select id="asianList">
  <option value="1">Asian Indian</option>
  <option value="2">Bangladeshi</option>
  <option value="3">Cambodian</option>
  <option value="4">Mainland Chinese</option>
  <option value="5">Filipino</option>
  <option value="6">Hmong</option>
  <option value="7">Japanese</option>
  <option value="8">Korean</option>
  <option value="9">Laotian</option>
  <option value="10">Pakistani</option>
  <option value="11">Taiwanese</option>
  <option value="12">Thai</option>
  <option value="13">Vietnamese</option>
</select>
<button type="button" id="refreshButton">Refresh</button>
</div>
<div id="tt" class="tooltip hidden">
  <div id="tipContainer">
    <div id="tipLocation"></div>
    <div id="tipInfo">
      
    </div>
  </div>
  <div class="arrow-box" style="right: 55.3542633056641px;"></div>
</div>
</div>
<div class="rightSide">
</div>
<script type = "text/javascript">


(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LabeledPie = factory();
  }
}(this, function () {

	var LabeledPie = function(parent) {

		this.svg = d3.select(parent)
			.append("svg")
			.append("g");

		d3.select(parent).select("svg").attr("width", "450").attr("height", "300");

		this.svg.append("g")
			.attr("class", "slices");
		this.svg.append("g")
			.attr("class", "labels");
		this.svg.append("g")
			.attr("class", "innerLabels");
		this.svg.append("g")
			.attr("class", "lines");

		this.width = 160,
		this.height = 160;
	    this.radius = Math.min(this.width, this.height) / 2;

		this.pie = d3.layout.pie()
			.sort(null);

		this.arc = d3.svg.arc()
			.outerRadius(this.radius * 0.8)
			.innerRadius(this.radius * 0.4);

		this.outerArc = d3.svg.arc()
			.innerRadius(this.radius * 0.85)
			.outerRadius(this.radius * 0.85);

		this.edgeArc = d3.svg.arc()
		    .innerRadius(this.radius * 0.8)
			.outerRadius(this.radius * 0.8);

		this.minimumDisplayedPercentage = 6;

		this.svg.attr("transform", "translate(" + 195 + "," + 90 + ")");

		this.minimumDisplayedLabel = 3;

		function transitionOverlappingLabel(textElement, newY) {
			var matrix = textElement.transform.baseVal[0].matrix;
			var oldY = matrix.f;

			var pos = [matrix.e, matrix.f];
			var delta = newY - oldY;


			d3.select(textElement)
			    .transition().duration(500)
			    .attrTween("transform", function(d) {
					return function(t) {
						pos[1] = oldY + t * delta;
						return "translate("+ pos +")";
					};
				});
		}

		function adjustOverlappingLabels() {

			var lastY = Infinity;  // matrix.f is y
			var f;

			// <text dy=".35em" transform="translate(80,-67.73521872367841)" style="text-anchor: start;">Asian Indian</text>
			var labels = d3.select(".labels").selectAll("text").filter(function() {
				var str = this.outerHTML;
				var result = !this.outerHTML.match("opacity: 0") && str.match("text-anchor: end");
				if (result)  {
                    f = this.transform.baseVal[0].matrix.f;
					console.log(this.getBBox(), this.transform.baseVal[0].matrix);
					var height = this.getBBox().height;
					if (f > (lastY - height)) {
						f = lastY - height;
						transitionOverlappingLabel(this, f);
					}
					//this.transform.baseVal[0].matrix.f = f;
					lastY = f;
				}
				return result;
			});
			console.log(labels.length, labels);
			return true;  // return true to stop timer from firing again
		}

         
        LabeledPie.prototype.setLabels = function(labels) {
        	this.labels = labels;
        }

        LabeledPie.prototype.setColorScale = function(color) {
        	this.color = color;
        }



		 LabeledPie.prototype.change = function(data) {

		 	var radius = this.radius;
		 	var labels = this.labels;
		 	var minimumDisplayedPercentage = this.minimumDisplayedPercentage;
		 	var arc = this.arc;
		 	var outerArc = this.outerArc;
		 	var edgeArc = this.edgeArc;
		 	var svg = this.svg;
		 	var pie = this.pie;
		 	var color = this.color;
		 	var minimumDisplayedLabel = this.minimumDisplayedLabel;


		    var sum = d3.sum(data);

			function getPercentage(d) {
				return Math.round(d.value/sum*100);
			}

			function getTitle(d, i) {
		      return labels[i] + ": " + d.value + ", " + getPercentage(d);
			}

			/* ------- PIE SLICES -------*/
			var slice = svg.select(".slices").selectAll("path.slice")
				.data(pie(data));

			slice.enter()
				.insert("path")
				.style("fill", function(d, i) { return color(i); })
				.attr("class", "slice");

		/*
			slice.append("svg:title")
		           .text(function(d, i) { 
		           	return getTitle(d, i); })
		*/

			slice		
				.transition().duration(1000)
				.attrTween("d", function(d) {
					this._current = this._current || d;
					var interpolate = d3.interpolate(this._current, d);
					this._current = interpolate(0);
					return function(t) {
						return arc(interpolate(t));
					};
				})

			slice.exit()
				.remove();

			/* ------- TEXT LABELS -------*/

			var text = svg.select(".labels").selectAll("text")
				.data(pie(data));

			text.enter()
				.append("text")
				.attr("dy", ".35em")
				.text(function(d, i) {
					return labels[i];
				});
			
			function midAngle(d){
				return d.startAngle + (d.endAngle - d.startAngle)/2;
			}

			text.transition().duration(1000)
			   .style("opacity", function(d) {
					return getPercentage(d) < minimumDisplayedLabel ? 0 : 1;
				})
				.attrTween("transform", function(d) {
					this._current = this._current || d;
					var interpolate = d3.interpolate(this._current, d);
					this._current = interpolate(0);
					return function(t) {
						var d2 = interpolate(t);
						var pos = outerArc.centroid(d2);
						pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
						return "translate("+ pos +")";
					};
				})
				.styleTween("text-anchor", function(d){
					this._current = this._current || d;
					var interpolate = d3.interpolate(this._current, d);
					this._current = interpolate(0);
					return function(t) {
						var d2 = interpolate(t);
						return midAngle(d2) < Math.PI ? "start":"end";
					};
				});

			text.exit()
				.remove();

				d3.timer(adjustOverlappingLabels, 1000);


			/* ------- SLICE TO TEXT POLYLINES -------*/

			var polyline = svg.select(".lines").selectAll("polyline")
				.data(pie(data));
			
			polyline.enter()
				.append("polyline");

			polyline.transition().duration(1000)
			    .style("opacity", function(d) {
					return getPercentage(d) < minimumDisplayedLabel ? 0 : 0.3;
				})
				.attrTween("points", function(d){
					this._current = this._current || d;
					var interpolate = d3.interpolate(this._current, d);
					this._current = interpolate(0);
					return function(t) {
						var d2 = interpolate(t);
						var pos = outerArc.centroid(d2);
						pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
						return [edgeArc.centroid(d2), outerArc.centroid(d2), pos];
					};			
				});
			
			polyline.exit()
				.remove();

		/* ------- PERCENTAGE LABELS -------*/

			var percent = svg.select(".innerLabels").selectAll("text")
				.data(pie(data));

			percent.enter()
				.insert("text")
				.attr("dy", ".35em");

			percent.transition().duration(1000)
			   .text(function(d) {
		            var percent = getPercentage(d);
					return percent > minimumDisplayedPercentage ? Math.round(percent) + "%" : "";
				})
			   .style("opacity", function(d) {
					return d.value/sum*100 > minimumDisplayedPercentage ? 1 : 0;
				})
				.attrTween("transform", function(d, i) {
					var bbox = this.getBBox();
					this._current = this._current || d;
					var interpolate = d3.interpolate(this._current, d);
					this._current = interpolate(0);
					return function(t) {
						var d2 = interpolate(t);
						var pos = arc.centroid(d2);
						pos[0] = pos[0] - bbox.width/2;
						//pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
						return "translate("+ pos +")";
					};
				});

			percent.exit()
				.remove();


		};



	};

    return LabeledPie;
}));

var incomePie = new LabeledPie("#tipInfo");

/*
(function () {

	var labels = ["< $25K", "$25K - $50K", "$50K - $75K", "$75K - $100K", "$100K - $200K", "> $200K"];

	var color = d3.scale.ordinal()
			.domain([0,1,2,3,4,5])
			.range(["#a50026","#f46d43","#fee08b","#d9ef8b","#66bd63","#006837"]);

	incomePie.setLabels(labels);
	incomePie.setColorScale(color);
		
})();

*/

/*
(function () {

	var labels = ["Latino", "White", "African American", "Native", "Asian", 
	    "Pacific Islander", "Other Race", "Mixed Race"];

	var color = d3.scale.ordinal()
			.domain([0,1,2,3,4,5, 6, 7])
			.range(["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666"]);

	incomePie.setLabels(labels);
	incomePie.setColorScale(color);
		
})();
*/

(function() {

	var labels = ["Asian Indian", "Bangladeshi", "Cambodian", "Mainland Chinese", "Filipino", "Hmong", "Japanese",
        "Korean", "Laotian", "Pakistani", "Taiwanese", "Thai", "Vietnamese"];

    var color = d3.scale.ordinal()
			.domain([0,1,2,3,4,5, 6, 7, 8, 9, 10, 11, 12])
			.range(["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928", "#cccccc"]);

	incomePie.setLabels(labels);
	incomePie.setColorScale(color);

})();



/**  TEST **/
/** THIS IS A HACK TO GET THE PIECHART SIZE BIG ENOUGH */
/*
var svg = d3.select("#tipInfo").append("svg")
    .attr("width", 5)
    .attr("height", 5)
    .append("g");
    */

    </script>
		<script type="text/javascript">

		var zipCodeMap = (function() {

			//Width and height
			var w = 650;
			var h = 1000;

			//Define map projection
			var projection = d3.geo.albersUsa()
								   .translate([w/2+16650, h/2+1700])
								   .scale([51000]);

			//Define path generator
			var path = d3.geo.path()
							 .projection(projection);
							 
			//Define quantize scale to sort data values into buckets of color
			var color = d3.scale.quantize()
								.range(["#a50026","#d73027","#f46d43","#fdae61","#fee08b","#ffffbf","#d9ef8b","#a6d96a","#66bd63","#1a9850","#006837"]);

			//Create SVG element
			var svg = d3.select(".rightSide")
						.append("svg")
						.attr("width", w)
						.attr("height", h);

			var statIndex = 1;	

			var statData;

			var geometry;

			var setStatIndex = function(newStatIndex) {
				statIndex = newStatIndex;
			};

			function getStatValue(d, stats) {
					var zip = d.properties.GEOID10;
					var counts = stats[zip];
					if (counts) {
						/*  CHANGE THIS FOR EACH RACE/INCOME LEVEL */
						return +counts[statIndex]/+counts[0];

					} else {
						return null;
					}
				
			    }	

			var updateColorDomain = function() {
				var min = d3.min(geometry.features, function(d) { 
						return getStatValue(d, statData); //+d.properties.GEOID10; 
					});
					var max = d3.max(geometry.features, function(d) { 
						return getStatValue(d, statData); //+d.properties.GEOID10;
					 })


				color.domain([
				  min, 
				  max
			      ]);	

			}

			var updateStats = function() {

				updateColorDomain()

				svg.selectAll("path")
				       .transition().duration(1000)
					   .attr("fill", function(d) {
					   		//Get data value
					   		var value = getStatValue(d, statData); 
					   		
					   		if (value) {
					   			//If value exists…
						   		return color(value);
					   		} else {
					   			//If value is undefined…
						   		return "#ccc";
					   		}
					   })

			};

			//Load in irs data
			d3.json("data/asian.json", function(irs) {
				statData = irs;


				//Load in GeoJSON data

				
                
                /*
                //   FOR IRS INCOME DATA
			    function getStatValue(d, stats) {
					var zip = d.properties.GEOID10;
					var counts = stats[zip];
					if (counts) {
						return +counts[counts.length - 1]/+counts[0];

					} else {
						return null;
					}
				
			    }	
			    */

			    function setToolTip(d, stats) {
			    	d3.select(".tooltip").classed("hidden", false);
   					var zip = d.properties.GEOID10;
					var counts = stats[zip].slice(1);

					incomePie.change(counts);
			    }		

				function getTitle(d) { 
                           	return d.properties.GEOID10 + ": " + d.properties.city;
                }

				d3.json("Bay_Area_Cities.json", function(json) {

					geometry = json;

					var lastZipClick = [];


					var min = d3.min(json.features, function(d) { 
						return getStatValue(d, irs); //+d.properties.GEOID10; 
					});
					var max = d3.max(json.features, function(d) { 
						return getStatValue(d, irs); //+d.properties.GEOID10;
					 })


					color.domain([
					  min, 
					  max
				      ]);	


					//Bind data and create one path per GeoJSON feature
					svg.selectAll("path")
					   .data(json.features)
					   .enter()
					   .append("path")
					   .attr("d", path)
					   .attr("stroke", "black")
					   .attr("fill", function(d) {
					   		//Get data value
					   		var value = getStatValue(d, irs); 
					   		
					   		if (value) {
					   			//If value exists…
						   		return color(value);
					   		} else {
					   			//If value is undefined…
						   		return "#ccc";
					   		}
					   })
					   .on("click", function (d) {
				            // Find previously selected, unselect
				            d3.select(".selected").classed("selected", false);

				            // Select current item
				            d3.select(this).classed("selected", true);
				            d3.select("#tipLocation").text(getTitle(d));
				            setToolTip(d, irs);
				            //console.log("x: " + d3.event.x + ", y: " + d3.event.y);
				            /*
				            d3.select('#tt')
                               .attr("style", "left: " + d3.event.x + "px; top: " + d3.event.y + "px;");*/
                            lastZipClick = [d3.event.x, d3.event.y];
				        })
					   .append("svg:title")
                           .text(function(d) { 
                           	return getTitle(d); });

                     /*  TODO: find a way to unselect tooltip when selecting off a zip code region */       

                     d3.select("body").on("click", function() {
                     	if (d3.event.x !== lastZipClick[0]  && d3.event.y !== lastZipClick[1]) {
                     	  d3.select(".selected").classed("selected", false);
                     	  d3.select(".tooltip").classed("hidden", true);
                       }
                       lastZipClick = [];
                     })
			
			});
        });

       return {
       	  setStatIndex: setStatIndex,
       	  updateStats: updateStats
       }
})();


d3.select("#refreshButton")
	.on("click", function() {
		var statIndex = d3.select("#asianList").node().value
		zipCodeMap.setStatIndex(statIndex);
		zipCodeMap.updateStats();
	});

				
			
		</script>
	</body>
</html>